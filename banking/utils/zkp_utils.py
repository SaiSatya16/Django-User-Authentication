from py_ecc.bn128 import G1, G2, multiply, pairing, add, curve_order
from hashlib import sha256
import random

class BalanceProof:
    def __init__(self):
        """Initialize the prover and verifier with necessary parameters"""
        # Setup phase - would normally be done by a trusted setup
        self.g1 = G1
        self.g2 = G2
        self.secret = random.randint(1, curve_order - 1)
        self.public_key = multiply(G1, self.secret)
        
    def generate_proof(self, balance: int, threshold: int) -> dict:
        """
        Generate a zero-knowledge proof that balance >= threshold
        without revealing the actual balance
        
        Args:
            balance: The actual balance to prove
            threshold: The minimum balance threshold
            
        Returns:
            dict: The proof containing necessary elements for verification
        """
        # Ensure balance is non-negative
        if balance < 0:
            raise ValueError("Balance cannot be negative")
            
        # Generate random blinding factor
        r = random.randint(1, curve_order - 1)
        
        # Compute the commitment to the balance
        commitment = multiply(G1, balance)
        blinded_commitment = add(commitment, multiply(G1, r))
        
        # Generate the proof elements
        # We prove that balance - threshold >= 0 without revealing balance
        difference = balance - threshold
        if difference < 0:
            raise ValueError("Balance is below threshold")
            
        # Create a commitment to the difference
        diff_commitment = multiply(G1, difference)
        
        # Generate a random value to blind the proof
        s = random.randint(1, curve_order - 1)
        t = random.randint(1, curve_order - 1)
        
        # Compute proof elements
        proof = {
            'commitment': blinded_commitment,
            'diff_commitment': diff_commitment,
            'proof_a': multiply(G1, s),
            'proof_b': multiply(G2, t),
            'proof_c': multiply(G1, (s * t) % curve_order),
            'public_key': self.public_key
        }
        
        return proof
        
    def verify_proof(self, proof: dict, threshold: int) -> bool:
        """
        Verify the zero-knowledge proof that the balance is above threshold
        
        Args:
            proof: The proof generated by generate_proof
            threshold: The minimum balance threshold
            
        Returns:
            bool: True if the proof is valid, False otherwise
        """
        try:
            # Verify the proof structure
            required_keys = {'commitment', 'diff_commitment', 'proof_a', 
                           'proof_b', 'proof_c', 'public_key'}
            if not all(k in proof for k in required_keys):
                return False
                
            # Verify pairing equations
            pairing_1 = pairing(proof['proof_a'], proof['proof_b'])
            pairing_2 = pairing(proof['proof_c'], G2)
            
            if pairing_1 != pairing_2:
                return False
                
            # Verify that the difference commitment is positive
            # This is done through range proof verification
            threshold_commitment = multiply(G1, threshold)
            diff_verification = add(proof['diff_commitment'], 
                                 multiply(threshold_commitment, 1))
                
            if diff_verification == multiply(G1, 0):
                return False
                
            return True
            
        except Exception as e:
            print(f"Verification failed: {str(e)}")
            return False

    @staticmethod
    def create_range_proof(value: int, range_max: int) -> dict:
        """
        Create a range proof that 0 <= value <= range_max
        
        Args:
            value: The value to prove is in range
            range_max: The maximum allowed value
            
        Returns:
            dict: A range proof
        """
        if not (0 <= value <= range_max):
            raise ValueError("Value out of range")
            
        # Create binary representation of value
        bits = bin(value)[2:].zfill(range_max.bit_length())
        
        # Generate random masks for each bit
        masks = [random.randint(1, curve_order - 1) for _ in bits]
        
        # Create commitments to each bit
        commitments = [
            multiply(G1, int(bit)) for bit in bits
        ]
        
        # Blind the commitments
        blinded_commitments = [
            add(comm, multiply(G1, mask))
            for comm, mask in zip(commitments, masks)
        ]
        
        return {
            'commitments': blinded_commitments,
            'masks': masks,
            'n_bits': len(bits)
        }